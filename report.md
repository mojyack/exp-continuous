# 連続シミュレーション 実験 レポート
## 目的
２つの質点の万有引力による天体の運動シミュレーションを行う

## 方法
以下の手順により、2つの天体の運動シミュレーションを行った
1. プログラムを用いた数値積分法を確かめる
2. ２つの質点の動きをシミュレーションするプログラムを作る
3. 2で作成したプログラムを改良する

## 手順1 プログラムを用いた数値積分法を確かめる
### 目的
数値積分をプログラムで表す方法を学ぶ。また、その精度を上げる方法を確かめる。  
また、それらのステップ数を変えて、理論値との差を吟味する。

### 方法
以下の2つの式の解を得るプログラムを作成する:
1. $\frac{dx}{dt}=ax$
2. $\frac{d^2x}{dt^2}=ax$

### 実装
#### 式1の場合
以下のプログラム`p1.cpp`(図1.1)を作成した。  

図1.1 p1.cpp
```C++
#include "util.hpp"

auto main(const int argc, const char* const argv[]) -> int {
    if(argc != 2) {
        return 1;
    }

    const auto n_r = from_chars<size_t>(argv[1]);
    if(!n_r) {
        return 1;
    }
    const auto n = n_r.value();

    const auto dt = 1.0 / n;
    const auto a  = -1.0;
    auto       t  = 0.0;
    auto       x  = 1.0;

    printf("%.5f %f\n", t, x);
    for(auto i = 0; i < n; i += 1) {
        x += a * x * dt;
        t += dt;
        printf("%.5f %f\n", t, x);
    }

    printf("result(n,x): %lu %f\n", n, x);
}
```
このプログラムはステップ数を引数として取る。  
#### 式2の場合
以下のプログラム`p2.cpp`(図1.2)を作成した。

図1.2 p2.cpp
```C++
#include "util.hpp"

auto main(const int argc, const char* const argv[]) -> int {
    if(argc != 2) {
        return 1;
    }

    const auto n_r = from_chars<size_t>(argv[1]);
    if(!n_r) {
        return 1;
    }
    const auto n = n_r.value();

    const auto dt = 1.0 / n;
    const auto a  = -1.0;
    auto       t  = 0.0;
    auto       x  = 1.0;
    auto       v  = 0.0;

    printf("%.5f %f\n", t, x);
    for(auto i = 0; i < n; i += 1) {
        x += v * dt;
        v += a * x * dt;
        t += dt;
        printf("%.5f %f\n", t, x);
    }

    printf("result(n,x): %lu %f\n", n, x);
}
```
このプログラムもp1と同様にステップ数を引数として取る。  

### 結果と考察
#### 式1の場合
このプログラム(p1)をステップ数20で実行したところ、次の図1.3のようになった。   

図1.3 p1の出力
```
$ ./a.out 20
0.00000 1.000000
0.05000 0.950000
0.10000 0.902500
0.15000 0.857375
0.20000 0.814506
0.25000 0.773781
0.30000 0.735092
0.35000 0.698337
0.40000 0.663420
0.45000 0.630249
0.50000 0.598737
0.55000 0.568800
0.60000 0.540360
0.65000 0.513342
0.70000 0.487675
0.75000 0.463291
0.80000 0.440127
0.85000 0.418120
0.90000 0.397214
0.95000 0.377354
1.00000 0.358486
result(n,x): 20 0.358486
```
さて、式1の解は、$a=-1$、$x(0)=1$とすると、$x=e^{-t}$となる。よって、$x(1){\fallingdotseq}0.367879$である。これにより、図1.6の結果はおおよそ正しいことが確認できた。  
ここで、ステップ数が計算結果に与える影響を調べるため、`bench-p1.sh`(図1.4)を用いた。

図1.4 bench-p1.sh  
```
#!/bin/zsh

set -e

function run() {
    for i in {1..100}; {
        $1 $i | grep result | cut -f 2- -d ' '
    }
}

run ./a.out > p1.txt
gnuplot -e '
    set xlabel "n";
    set ylabel "x(1)";
    set terminal pngcairo;
    set output "/tmp/output.png";
    plot "p1.txt" with linespoints title "x(1)", 
          exp(-1);
' && imgview /tmp/output.png
```
これは、ステップ数を1から100まで変えながら計算し、それをプロットするものである。この結果、図1.5のようなグラフが得られた。

図1.5 式1をステップ数$n$を変えながら実行した結果  
![g1.5](https://github.com/mojyack/exp-continuous/blob/main/assets/g1.5.png?raw=true)

図1.5から、nが大きくなるにつれて計算結果が理論値に近づく様子がわかった。

#### 式2の場合
このプログラム(p2)をステップ数20で実行したところ、次の図1.6のようになった。   

図1.6 p2の出力  
```
$ ./a.out 20
0.00000 1.000000
0.05000 1.000000
0.10000 0.997500
0.15000 0.992506
0.20000 0.985031
0.25000 0.975094
0.30000 0.962718
0.35000 0.947936
0.40000 0.930784
0.45000 0.911305
0.50000 0.889548
0.55000 0.865567
0.60000 0.839422
0.65000 0.811179
0.70000 0.780907
0.75000 0.748683
0.80000 0.714588
0.85000 0.678706
0.90000 0.641127
0.95000 0.601946
1.00000 0.561259
result(n,x): 20 0.561259
```

さて、式2の解は、$a=-1$、$x(0)=1$とすると、$x=\frac12e^{\sqrt{a}t}+\frac12e^{-\sqrt{a}t}=\cos{t}$となる。よって、$x(1){\fallingdotseq}0.540302$である。これにより、図1.6の結果はおおよそ正しいことが確認できた。  
ここで、`bench-p1.sh`に少しだけ手を加え、同様にステップ数と計算結果をプロットすると図1.7のようになった。

図1.7 式2をステップ数$n$を変えながら実行した結果  
![g1.7](https://github.com/mojyack/exp-continuous/blob/main/assets/g1.7.png?raw=true)

図1.7から、nが大きくなるにつれて計算結果が理論値に近づく様子がわかった。

## 手順2 ２つの質点の動きをシミュレーションするプログラムを作る
### 目的
決められた初期条件から、２つの質点の動きをシミュレーションできるようになる
### 手段
二天体シュミレーションを行うプログラムを作成する。  
また、それにより得られる天体の動きをプロットし、妥当性を検証する。
## 結果
以下のプログラム`p3-noinput.cpp`(図2.1)を作成した。

図2.1 p3-noinput.cpp
```C++
#include "util.hpp"

struct Planet {
    double m;
    double px;
    double py;
    double vx;
    double vy;
};

class Simulator {
  private:
    static constexpr auto g = 4.0;

    double dt;
    Planet o1;
    Planet o2;

    auto force() -> std::array<double, 2> {
        const auto dx  = (o1.px - o2.px);
        const auto dy  = (o1.py - o2.py);
        const auto r   = std::sqrt(dx * dx + dy * dy);
        const auto mmg = o1.m * o2.m * g;
        const auto fx  = -mmg * dx / (r * r * r);
        const auto fy  = -mmg * dy / (r * r * r);
        return {double(fx), double(fy)};
    }

  public:
    auto update() -> void {
        const auto [fx, fy] = force();

        o1.vx += fx * dt / o1.m;
        o1.vy += fy * dt / o1.m;
        o1.px += o1.vx * dt;
        o1.py += o1.vy * dt;

        o2.vx += -fx * dt / o2.m;
        o2.vy += -fy * dt / o2.m;
        o2.px += o2.vx * dt;
        o2.py += o2.vy * dt;
    }

    auto get_planets() const -> std::array<const Planet*, 2> {
        return {&o1, &o2};
    }

    Simulator(const double dt) : dt(dt) {
        o1 = Planet{1, 1, 0, 0, 1};
        o2 = Planet{1, -1, 0, 0, -1};
    }
};

auto main(const int argc, const char* argv[]) -> int {
    if(argc != 3) {
        return 1;
    }

    const auto dt_r = from_chars<double>(argv[1]);
    if(!dt_r) {
        return 2;
    }
    const auto dt = dt_r.value();

    const auto limit_r = from_chars<size_t>(argv[2]);
    if(!limit_r) {
        return 2;
    }
    const auto limit = limit_r.value();

    auto simulator = Simulator(dt);
    for(auto i = 0; i < limit; i += 1) {
        const auto [p1, p2] = simulator.get_planets();
        printf("%d %lf %lf %lf %lf\n", i, p1->px, p1->py, p2->px, p2->py);
        simulator.update();
    }

    return 0;
}
```

`Planet`クラスは質量、位置、速度を持っており、`Simulator`クラスは惑星2つの動きをシュミレーションする。  
また、このプログラムは2つの引数を取る。1つ目はステップ毎の時間(dt)、2つ目は合計ステップ数である。  
なお、初期条件は惑星1が質量1、位置(1, 0)、速度(0, 1)、惑星2が質量1、位置(-1, 0)、速度(0, -1)とした。  
このプログラムを引数0.05、200で実行したところ、次の図2.2の出力が得られた。

図2.2 p3-noinputをdt=0.05で200ステップ実行した結果
```
$ ./a.out 0.05 200
0 1.000000 0.000000 -1.000000 0.000000
1 0.997500 0.050000 -0.997500 -0.050000
2 0.992497 0.099875 -0.992497 -0.099875
3 0.984994 0.149498 -0.984994 -0.149498
4 0.975001 0.198743 -0.975001 -0.198743
5 0.962533 0.247483 -0.962533 -0.247483
6 0.947615 0.295594 -0.947615 -0.295594
7 0.930274 0.342949 -0.930274 -0.342949
8 0.910547 0.389424 -0.910547 -0.389424
9 0.888477 0.434897 -0.888477 -0.434897
10 0.864111 0.479246 -0.864111 -0.479246
11 0.837507 0.522354 -0.837507 -0.522354
12 0.808725 0.564104 -0.808725 -0.564104
13 0.777834 0.604383 -0.777834 -0.604383
14 0.744909 0.643080 -0.744909 -0.643080
15 0.710030 0.680091 -0.710030 -0.680091
16 0.673283 0.715313 -0.673283 -0.715313
17 0.634760 0.748649 -0.634760 -0.748649
18 0.594559 0.780005 -0.594559 -0.780005
19 0.552783 0.809294 -0.552783 -0.809294
20 0.509539 0.836434 -0.509539 -0.836434
21 0.464938 0.861349 -0.464938 -0.861349
22 0.419099 0.883967 -0.419099 -0.883967
23 0.372140 0.904225 -0.372140 -0.904225
24 0.324186 0.922064 -0.324186 -0.922064
25 0.275364 0.937435 -0.275364 -0.937435
26 0.225804 0.950293 -0.225804 -0.950293
27 0.175638 0.960602 -0.175638 -0.960602
28 0.125001 0.968332 -0.125001 -0.968332
29 0.074028 0.973461 -0.074028 -0.973461
30 0.022856 0.975975 -0.022856 -0.975975
31 -0.028378 0.975866 0.028378 -0.975866
32 -0.079535 0.973135 0.079535 -0.973135
33 -0.130478 0.967790 0.130478 -0.967790
34 -0.181072 0.959848 0.181072 -0.959848
35 -0.231179 0.949330 0.231179 -0.949330
36 -0.280667 0.936269 0.280667 -0.936269
37 -0.329404 0.920700 0.329404 -0.920700
38 -0.377259 0.902670 0.377259 -0.902670
39 -0.424108 0.882230 0.424108 -0.882230
40 -0.469826 0.859439 0.469826 -0.859439
41 -0.514294 0.834361 0.514294 -0.834361
42 -0.557397 0.807068 0.557397 -0.807068
43 -0.599023 0.777636 0.599023 -0.777636
44 -0.639066 0.746149 0.639066 -0.746149
45 -0.677423 0.712695 0.677423 -0.712695
46 -0.713999 0.677366 0.713999 -0.677366
47 -0.748703 0.640262 0.748703 -0.640262
48 -0.781449 0.601482 0.781449 -0.601482
49 -0.812158 0.561135 0.812158 -0.561135
50 -0.840756 0.519330 0.840756 -0.519330
51 -0.867176 0.476179 0.867176 -0.476179
52 -0.891357 0.431799 0.891357 -0.431799
53 -0.913245 0.386308 0.913245 -0.386308
54 -0.932790 0.339826 0.932790 -0.339826
55 -0.949953 0.292476 0.949953 -0.292476
56 -0.964697 0.244381 0.964697 -0.244381
57 -0.976994 0.195666 0.976994 -0.195666
58 -0.986822 0.146457 0.986822 -0.146457
59 -0.994165 0.096879 0.994165 -0.096879
60 -0.999014 0.047058 0.999014 -0.047058
61 -1.001367 -0.002880 1.001367 0.002880
62 -1.001227 -0.052812 1.001227 0.052812
63 -0.998603 -0.102612 0.998603 0.102612
64 -0.993511 -0.152159 0.993511 0.152159
65 -0.985973 -0.201331 0.985973 0.201331
66 -0.976017 -0.250009 0.976017 0.250009
67 -0.963674 -0.298076 0.963674 0.298076
68 -0.948985 -0.345417 0.948985 0.345417
69 -0.931992 -0.391920 0.931992 0.391920
70 -0.912744 -0.437474 0.912744 0.437474
71 -0.891296 -0.481974 0.891296 0.481974
72 -0.867706 -0.525316 0.867706 0.525316
73 -0.842037 -0.567399 0.842037 0.567399
74 -0.814358 -0.608127 0.814358 0.608127
75 -0.784739 -0.647408 0.784739 0.647408
76 -0.753257 -0.685151 0.753257 0.685151
77 -0.719992 -0.721271 0.719992 0.721271
78 -0.685025 -0.755688 0.685025 0.755688
79 -0.648445 -0.788324 0.648445 0.788324
80 -0.610341 -0.819108 0.610341 0.819108
81 -0.570805 -0.847970 0.570805 0.847970
82 -0.529933 -0.874848 0.529933 0.874848
83 -0.487823 -0.899681 0.487823 0.899681
84 -0.444575 -0.922416 0.444575 0.922416
85 -0.400292 -0.943004 0.400292 0.943004
86 -0.355078 -0.961398 0.355078 0.961398
87 -0.309040 -0.977560 0.309040 0.977560
88 -0.262285 -0.991454 0.262285 0.991454
89 -0.214921 -1.003051 0.214921 1.003051
90 -0.167060 -1.012324 0.167060 1.012324
91 -0.118813 -1.019254 0.118813 1.019254
92 -0.070290 -1.023826 0.070290 1.023826
93 -0.021605 -1.026030 0.021605 1.026030
94 0.027130 -1.025860 -0.027130 1.025860
95 0.075802 -1.023318 -0.075802 1.023318
96 0.124299 -1.018407 -0.124299 1.018407
97 0.172508 -1.011139 -0.172508 1.011139
98 0.220318 -1.001529 -0.220318 1.001529
99 0.267617 -0.989597 -0.267617 0.989597
100 0.314295 -0.975369 -0.314295 0.975369
101 0.360242 -0.958874 -0.360242 0.958874
102 0.405352 -0.940149 -0.405352 0.940149
103 0.449517 -0.919234 -0.449517 0.919234
104 0.492634 -0.896174 -0.492634 0.896174
105 0.534599 -0.871020 -0.534599 0.871020
106 0.575312 -0.843825 -0.575312 0.843825
107 0.614674 -0.814650 -0.614674 0.814650
108 0.652591 -0.783558 -0.652591 0.783558
109 0.688970 -0.750620 -0.688970 0.750620
110 0.723719 -0.715907 -0.723719 0.715907
111 0.756754 -0.679497 -0.756754 0.679497
112 0.787991 -0.641473 -0.787991 0.641473
113 0.817349 -0.601920 -0.817349 0.601920
114 0.844754 -0.560929 -0.844754 0.560929
115 0.870133 -0.518592 -0.870133 0.518592
116 0.893419 -0.475008 -0.893419 0.475008
117 0.914550 -0.430278 -0.914550 0.430278
118 0.933466 -0.384506 -0.933466 0.384506
119 0.950113 -0.337799 -0.950113 0.337799
120 0.964445 -0.290269 -0.964445 0.290269
121 0.976416 -0.242029 -0.976416 0.242029
122 0.985990 -0.193194 -0.985990 0.193194
123 0.993133 -0.143883 -0.993133 0.143883
124 0.997819 -0.094217 -0.997819 0.094217
125 1.000028 -0.044316 -1.000028 0.044316
126 0.999744 0.005695 -0.999744 -0.005695
127 0.996959 0.055692 -0.996959 -0.055692
128 0.991670 0.105549 -0.991670 -0.105549
129 0.983882 0.155140 -0.983882 -0.155140
130 0.973604 0.204339 -0.973604 -0.204339
131 0.960855 0.253019 -0.960855 -0.253019
132 0.945656 0.301053 -0.945656 -0.301053
133 0.928039 0.348318 -0.928039 -0.348318
134 0.908040 0.394689 -0.908040 -0.394689
135 0.885702 0.440043 -0.885702 -0.440043
136 0.861075 0.484260 -0.861075 -0.484260
137 0.834215 0.527221 -0.834215 -0.527221
138 0.805185 0.568811 -0.805185 -0.568811
139 0.774055 0.608917 -0.774055 -0.608917
140 0.740898 0.647429 -0.740898 -0.647429
141 0.705797 0.684242 -0.705797 -0.684242
142 0.668838 0.719254 -0.668838 -0.719254
143 0.630115 0.752368 -0.630115 -0.752368
144 0.589725 0.783492 -0.589725 -0.783492
145 0.547771 0.812539 -0.547771 -0.812539
146 0.504362 0.839428 -0.504362 -0.839428
147 0.459611 0.864081 -0.459611 -0.864081
148 0.413634 0.886431 -0.413634 -0.886431
149 0.366552 0.906413 -0.366552 -0.906413
150 0.318490 0.923970 -0.318490 -0.923970
151 0.269575 0.939053 -0.269575 -0.939053
152 0.219937 0.951619 -0.219937 -0.951619
153 0.169709 0.961631 -0.169709 -0.961631
154 0.119025 0.969061 -0.119025 -0.969061
155 0.068022 0.973888 -0.068022 -0.973888
156 0.016835 0.976099 -0.016835 -0.976099
157 -0.034396 0.975686 0.034396 -0.975686
158 -0.085535 0.972653 0.085535 -0.972653
159 -0.136444 0.967007 0.136444 -0.967007
160 -0.186987 0.958766 0.186987 -0.958766
161 -0.237029 0.947953 0.237029 -0.947953
162 -0.286435 0.934600 0.286435 -0.934600
163 -0.335075 0.918745 0.335075 -0.918745
164 -0.382819 0.900435 0.382819 -0.900435
165 -0.429542 0.879721 0.429542 -0.879721
166 -0.475119 0.856663 0.475119 -0.856663
167 -0.519434 0.831327 0.519434 -0.831327
168 -0.562369 0.803785 0.562369 -0.803785
169 -0.603816 0.774114 0.603816 -0.774114
170 -0.643667 0.742398 0.643667 -0.742398
171 -0.681822 0.708725 0.681822 -0.708725
172 -0.718184 0.673190 0.718184 -0.673190
173 -0.752665 0.635890 0.752665 -0.635890
174 -0.785178 0.596928 0.785178 -0.596928
175 -0.815646 0.556411 0.815646 -0.556411
176 -0.843995 0.514449 0.843995 -0.514449
177 -0.870159 0.471155 0.870159 -0.471155
178 -0.894078 0.426646 0.894078 -0.426646
179 -0.915698 0.381039 0.915698 -0.381039
180 -0.934971 0.334456 0.934971 -0.334456
181 -0.951858 0.287019 0.951858 -0.287019
182 -0.966322 0.238852 0.966322 -0.238852
183 -0.978337 0.190079 0.978337 -0.190079
184 -0.987882 0.140826 0.987882 -0.140826
185 -0.994941 0.091219 0.994941 -0.091219
186 -0.999506 0.041383 0.999506 -0.041383
187 -1.001575 -0.008556 1.001575 0.008556
188 -1.001152 -0.058474 1.001152 0.058474
189 -0.998247 -0.108246 0.998247 0.108246
190 -0.992877 -0.157752 0.992877 0.157752
191 -0.985065 -0.206869 0.985065 0.206869
192 -0.974837 -0.255480 0.974837 0.255480
193 -0.962229 -0.303466 0.962229 0.303466
194 -0.947278 -0.350713 0.947278 0.350713
195 -0.930029 -0.397110 0.930029 0.397110
196 -0.910532 -0.442547 0.910532 0.442547
197 -0.888842 -0.486917 0.888842 0.486917
198 -0.865016 -0.530119 0.865016 0.530119
199 -0.839120 -0.572051 0.839120 0.572051
```
## 考察
さて、図2.2をプロットすると、以下の図2.3のようになった。

図2.3 p3-noinputをdt=0.05で200ステップ実行した結果のグラフ
![g2.3](https://github.com/mojyack/exp-continuous/blob/main/assets/g2.3.png?raw=true)

理論的には、この天体は同一円軌道を描くはずだが、このグラフではそうなっていない。これは、計算精度が不足しているからだと考察できる。例えば、単純にdt=0.01として実行してみると、図2.4のようになる。

図2.4 p3-noinputをdt=0.01で1000ステップ実行した結果のグラフ
![g2.4](https://github.com/mojyack/exp-continuous/blob/main/assets/g2.4.png?raw=true)

このように、より円軌道に近づいている。  
ステップ幅を狭める以外にも、計算に使うアルゴリズムを改良することでも精度を上げることはできる。これについては、次の手順で行う。

## 手順3 プログラムを改良する
### 目的
手順2で作成したプログラムを改良する。具体的には、精度の向上と利便性を高めることを目標とする。
### 方法
積分に修正オイラー法などを用いることで、精度の向上を図る  
初期条件を実行時に定められるように改良する
### 実装
これらを盛り込んだのが、図3.1のプログラム(p3)である。

図3.1 p3.cpp
```C++
#include "util.hpp"

struct Vec2 {
    double x;
    double y;
};

struct Planet {
    std::array<Vec2, 3> p; // [0] position, [1] velocity, [2] acceleration
    double              m;

    static auto from_stdin() -> Planet {
        const auto m  = read_stdin<double>("m? ");
        const auto px = read_stdin<double>("px? ");
        const auto py = read_stdin<double>("py? ");
        const auto vx = read_stdin<double>("vx? ");
        const auto vy = read_stdin<double>("vy? ");
        return Planet{{px, py, vx, vy, 0, 0}, m};
    }
};

enum class Method {
    Euler,
    MEuler,
    Runge,
};

class Simulator {
  private:
    static constexpr auto g = 4.0;

    Method method;
    double dt;
    Planet o1;
    Planet o2;

    // update acceleration
    static auto kepler(Planet& o1, Planet& o2) -> void {
        const auto dx = (o1.p[0].x - o2.p[0].x);
        const auto dy = (o1.p[0].y - o2.p[0].y);
        const auto r  = std::sqrt(dx * dx + dy * dy);

        o1.p[2].x = -g * o2.m * dx / (r * r * r);
        o1.p[2].y = -g * o2.m * dy / (r * r * r);
        o2.p[2].x = +g * o1.m * dx / (r * r * r);
        o2.p[2].y = +g * o1.m * dy / (r * r * r);
    }

    static auto update_euler(Planet& o1, Planet& o2, const double dt) -> void {
        kepler(o1, o2);

        for(auto i = 0; i <= 2; i += 1) {
            o1.p[i].x += dt * o1.p[i + 1].x;
            o1.p[i].y += dt * o1.p[i + 1].y;

            o2.p[i].x += dt * o2.p[i + 1].x;
            o2.p[i].y += dt * o2.p[i + 1].y;
        }
    }

    static auto update_meuler(Planet& o1, Planet& o2, const double dt) -> void {
        const auto do_meuler = [dt](Planet o1, Planet o2) -> Planet {
            kepler(o1, o2);
            auto k1 = o1;
            auto k2 = o1;
            for(auto i = 0; i < 2; i += 1) {
                k1.p[i].x = dt * k1.p[i + 1].x;
                k1.p[i].y = dt * k1.p[i + 1].y;
                k2.p[i].x += k1.p[i].x;
                k2.p[i].y += k1.p[i].y;
            }
            for(auto i = 0; i < 2; i += 1) {
                k2.p[i].x = dt * k2.p[i + 1].x;
                k2.p[i].y = dt * k2.p[i + 1].y;
                o1.p[i].x += (k1.p[i].x + k2.p[i].x) / 2.0;
                o1.p[i].y += (k1.p[i].y + k2.p[i].y) / 2.0;
            }

            return o1;
        };

        const auto t1 = do_meuler(o1, o2);
        const auto t2 = do_meuler(o2, o1);

        o1 = t1;
        o2 = t2;
    }

    static auto update_runge(Planet& o1, Planet& o2, const double dt) -> void {
        const auto do_runge = [dt](Planet o1, Planet o2) -> Planet {
            auto k1 = o1;
            auto k2 = o1;
            auto k3 = o1;
            auto k4 = o1;
            kepler(k1, o2);
            for(auto i = 0; i < 2; i += 1) {
                k1.p[i].x = dt * k1.p[i + 1].x;
                k1.p[i].y = dt * k1.p[i + 1].y;
                k2.p[i].x += k1.p[i].x / 2.0;
                k2.p[i].y += k1.p[i].y / 2.0;
            }
            kepler(k2, o2);
            for(auto i = 0; i < 2; i += 1) {
                k2.p[i].x = dt * k2.p[i + 1].x;
                k2.p[i].y = dt * k2.p[i + 1].y;
                k3.p[i].x += k2.p[i].x / 2.0;
                k3.p[i].y += k2.p[i].y / 2.0;
            }
            kepler(k3, o2);
            for(auto i = 0; i < 2; i += 1) {
                k3.p[i].x = dt * k3.p[i + 1].x;
                k3.p[i].y = dt * k3.p[i + 1].y;
                k4.p[i].x += k3.p[i].x;
                k4.p[i].y += k3.p[i].y;
            }
            kepler(k4, o2);
            for(auto i = 0; i < 2; i += 1) {
                k4.p[i].x = dt * k4.p[i + 1].x;
                k4.p[i].y = dt * k4.p[i + 1].y;

                o1.p[i].x += (k1.p[i].x + 2.0 * k2.p[i].x + 2.0 * k3.p[i].x + k4.p[i].x) / 6.0;
                o1.p[i].y += (k1.p[i].y + 2.0 * k2.p[i].y + 2.0 * k3.p[i].y + k4.p[i].y) / 6.0;
            }

            return o1;
        };

        const auto t1 = do_runge(o1, o2);
        const auto t2 = do_runge(o2, o1);

        o1 = t1;
        o2 = t2;
    }

  public:
    auto update() -> void {
        switch(method) {
        case Method::Euler:
            update_euler(o1, o2, dt);
            break;
        case Method::MEuler:
            update_meuler(o1, o2, dt);
            break;
        case Method::Runge:
            update_runge(o1, o2, dt);
            break;
        }
    }

    auto get_planets() const -> std::array<const Planet*, 2> {
        return {&o1, &o2};
    }

    Simulator(const Method method, const double dt)
        : method(method),
          dt(dt) {
        print("planet 1: ");
        o1 = Planet::from_stdin();
        print("planet 2: ");
        o2 = Planet::from_stdin();
    }
};

auto main(const int argc, const char* argv[]) -> int {
    if(argc != 4) {
        return 1;
    }

    auto method = Method();
    if(std::strcmp(argv[1], "euler") == 0) {
        method = Method::Euler;
    } else if(std::strcmp(argv[1], "meuler") == 0) {
        method = Method::MEuler;
    } else if(std::strcmp(argv[1], "runge") == 0) {
        method = Method::Runge;
    } else {
        puts("unknown method");
        return 1;
    }

    const auto dt_r = from_chars<double>(argv[2]);
    if(!dt_r) {
        return 2;
    }
    const auto dt = dt_r.value();

    const auto limit_r = from_chars<size_t>(argv[3]);
    if(!limit_r) {
        return 2;
    }
    const auto limit = limit_r.value();

    auto simulator = Simulator(method, dt);
    for(auto i = 0; i < limit; i += 1) {
        const auto [p1, p2] = simulator.get_planets();
        printf("%d %lf %lf %lf %lf\n", i, p1->p[0].x, p1->p[0].y, p2->p[0].x, p2->p[0].y);
        simulator.update();
    }

    return 0;
}
```

プログラムp3には実行時に天体2つの質量、位置、速度を設定する。また、第一引数として"euler"、"meuler"、"runge"のいずれかを指定でき、それぞれ計算にオイラー法、修正オイラー法、ルンゲクッタ法を用いるようになる。
### 結果
計算法によりどのくらい精度が向上するのかを確かめるため、ステップ幅とステップ数は図2.2のときと同じにして、3つの計算法で計算した結果をプロットした。それぞれ図3.2、3.3、3.4である。  
初期条件は手順2と同様、惑星1が質量1、位置(1, 0)、速度(0, 1)、惑星2が質量1、位置(-1, 0)、速度(0, -1)とした。  

図3.2 p3をdt=0.05で200ステップ、オイラー法で実行した結果のグラフ
![g3.2](https://github.com/mojyack/exp-continuous/blob/main/assets/g3.2.png?raw=true)

図3.3 p3をdt=0.05で200ステップ、修正オイラー法で実行した結果のグラフ
![g3.3](https://github.com/mojyack/exp-continuous/blob/main/assets/g3.3.png?raw=true)

図3.4 p3をdt=0.05で200ステップ、ルンゲクッタ法で実行した結果のグラフ
![g3.4](https://github.com/mojyack/exp-continuous/blob/main/assets/g3.4.png?raw=true)
### 考察
この手順3によって、プログラムの初期条件を変更できるようになり、プログラムの利便性が向上した。また、計算法を変えることで、図3.2、3.3、3.4のように、計算精度も改善できることを示せた。
